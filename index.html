<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Stats Table</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="splashScreen">
        <div id="splashContent">
            <div id="splashClose">
                <i class="material-icons close">close</i>
            </div>
            <h2 class="underline-extended">lirs-analyzer version 0.2</h2>
            <ul>
                <li>updated stats [30/08/24]</li>
                <li>added update splash screen and button</li>
                <li>changed the table to be sorted by games played by default</li>
                <li>if the game lasted less than 20 seconds, or you played for less than 20 seconds, it is not counted</li>
                <li>fixed some player usernames not showing</li>
            </ul>
            <p2>this project is mantained and hosted on <a href="https://github.com/shaunx777/lirs-analyzer">Github</a></p2>
        </div>
    </div>
    
    <h1>Player Stats</h1>

    <div id="searchContainer">
        <input type="text" id="searchInput" placeholder="Search for players...">
        <div id="splashInfo">
            <svg class="info" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>
        </div>
    </div>

    <div id="blurOverlay"></div>

    <table id="playerTable">
        <thead>
            <tr>
                <th data-sort="username">Username</th>
                <th data-sort="games.total">Total Games</th>
                <th class="pad" data-sort="games.wins">Wins</th>
                <th class="pad" data-sort="games.losses">Losses</th>
                <th class="pad" data-sort="games.draws">Draws</th>
                <th data-sort="games.red">Games as Red</th>
                <th data-sort="games.blue">Games as&nbsp;Blue</th>
                <th data-sort="performance.playtimeMinutes">Playtime (min)</th>
                <th data-sort="performance.winRate">Win Rate</th>
                <th data-sort="performance.goalsPerGame">Goals per Game</th>
                <th data-sort="performance.assistsPerGame">Assists per Game</th>
                <th data-sort="performance.csPerGame">CS per Game</th>
                <th data-sort="performance.ogPerGame">OG per Game</th>
                <th data-sort="total.goals">Total Goals</th>
                <th data-sort="total.assists">Total Assists</th>
                <th data-sort="total.cs">Total CS</th>
                <th data-sort="total.og">Total OG</th>
            </tr>
        </thead>
        <tbody>
            <!-- Player rows here -->
        </tbody>
    </table>

    <script>
        let playerData = [];
        let sortOrder = {};
        let newPlayerData = []
        let currentChunk = 0;
        const CHUNK_SIZE = 100;

        const VERSION = 0.2

        async function fetchPlayerData() {
            try {
                const response = await fetch('src/statistics.json?' + new Date());
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                let data = await response.json();
                return data.players;
            } catch (error) {
                console.error('There has been a problem with the fetch operation:', error);
                return [];
            }
        }

        function createTableRow(player) {
            const [username, stats, index] = player;
            return `
                <tr>
                    <td>${index}, ${username}</td>
                    <td>${stats.games.total}</td>
                    <td>${stats.games.wins}</td>
                    <td>${stats.games.losses}</td>
                    <td>${stats.games.draws}</td>
                    <td>${stats.games.red}</td>
                    <td>${stats.games.blue}</td>
                    <td>${stats.performance.playtimeMinutes}</td>
                    <td>${stats.performance.winRate}%</td>
                    <td>${stats.performance.goalsPerGame}</td>
                    <td>${stats.performance.assistsPerGame}</td>
                    <td>${stats.performance.csPerGame}</td>
                    <td>${stats.performance.ogPerGame}</td>
                    <td>${stats.total.goals}</td>
                    <td>${stats.total.assists}</td>
                    <td>${stats.total.cs}</td>
                    <td>${stats.total.og}</td>
                </tr>
            `;
        }

        function renderTableChunk(playerData, chunkIndex) {
            const start = chunkIndex * CHUNK_SIZE;
            const end = start + CHUNK_SIZE;
            const chunkData = playerData.slice(start, end);

            const tableBody = document.querySelector('#playerTable tbody');
            tableBody.insertAdjacentHTML('beforeend', chunkData.map(createTableRow).join(''));
        }

        function sortTable(key) {
            const sortDir = sortOrder[key] === 'desc' ? 'asc' : 'desc';
            sortOrder = { [key]: sortDir };
        
            playerData.sort((a, b) => {
                const aValue = extractValue(a, key);
                const bValue = extractValue(b, key);

                if (typeof aValue === 'string') {
                    return sortDir === 'asc' ? aValue.toLowerCase() < bValue.toLowerCase() : aValue.toLowerCase() > bValue.toLowerCase();
                } else {
                    return sortDir === 'asc' ? aValue - bValue : bValue - aValue;
                }
            });

            playerData.forEach((player, index) => {
				player[0] = sanitizeHTMLString(player[0])
                player[2] = index + 1
            });

            currentChunk = 0;
            document.querySelector('#playerTable tbody').innerHTML = '';
            newPlayerData = playerData.slice();

      			const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      			if (searchTerm) {
                filterTable(newPlayerData)
            }
            else {
                renderTableChunk(newPlayerData, currentChunk);
            }
      
            document.querySelectorAll('th').forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));
            document.querySelector(`th[data-sort="${key}"]`).classList.add(sortDir === 'asc' ? 'sorted-asc' : 'sorted-desc');
        }


		function sanitizeHTMLString(str) {
            return str.replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/'/g, '&#39;')
                    .replace(/"/g, '&quot;');
        }

        function extractValue(obj, path) {
            if (path === "username") {
                return obj[0];
            }
            return path.split('.').reduce((acc, part) => acc && acc[part], obj[1]);
        }

        function filterTable() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const searchTerms = searchTerm.split(',').map(term => term.trim());

            playerData.forEach((player, index) => {
				player[0] = sanitizeHTMLString(player[0])
                player[2] = index + 1;
            });

            const filteredData = playerData.filter(([username]) => {
                return searchTerms.some(term => {
          			if (/^"[^"]*"$/.test(term) || /^'[^']*'$/.test(term)) {
          				return username.toLowerCase() == term.slice(1, -1);;
          			} else {
          				return username.toLowerCase().includes(term);
          			}
          		});
            });

            currentChunk = 0;
            document.querySelector('#playerTable tbody').innerHTML = '';
            newPlayerData = filteredData.slice();
            renderTableChunk(newPlayerData, currentChunk);
        }

        function loadMorePlayers() {
            currentChunk++;
            renderTableChunk(newPlayerData, currentChunk);
        }

        function handleScroll() {
            const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
            if (scrollTop + clientHeight >= scrollHeight - 5) {
                loadMorePlayers();
            }
        }

        const splashScreen = document.getElementById("splashScreen")
        const blurOverlay = document.getElementById("blurOverlay")
        const splashContent = document.getElementById("splashContent")
    
        function renderSplash() {
            document.body.style.overflow = "hidden"
            blurOverlay.style.visibility = "visible"
            blurOverlay.style.opacity = 1
            splashScreen.style.height = "5%"
            splashScreen.style.visibility = "visible"
            splashScreen.classList.add("splashAnimFast")
            splashContent.classList.add("splashContentAnimFast")

        }

        function closeSplash() {
            window.localStorage.setItem("version", "0.2")
            document.body.style.overflow = "visible"
            splashScreen.style.visibility = "hidden"
            splashScreen.classList.remove("splashAnim")
            splashContent.style.opacity = 0
            splashContent.classList.remove("splashContentAnim")
            splashScreen.classList.remove("splashAnimFast")
            splashContent.classList.remove("splashContentAnimFast")

            
            blurOverlay.style.opacity = 0
            setTimeout(() => {blurOverlay.style.visibility = "hidden"}, 500)
        }

        const lastVersion = parseFloat(window.localStorage.getItem("version"))
        if (lastVersion >= VERSION) {
            document.body.style.overflow = "visible"
            splashScreen.style.visibility = "hidden"
            splashScreen.classList.remove("splashAnim")
            splashContent.classList.remove("splashContentAnim")
            blurOverlay.style.visibility = "hidden"
        }
        else {
            splashScreen.classList.add("splashAnim")
            splashContent.classList.add("splashContentAnim")
        }

        document.addEventListener('DOMContentLoaded', async () => {


            playerData = await fetchPlayerData();
            sortTable("games.total")
            
            document.getElementById('searchInput').addEventListener('input', filterTable);

            document.getElementsByClassName("info")[0].addEventListener("click", renderSplash) 
            document.getElementsByClassName("close")[0].addEventListener("click", closeSplash) 

            document.querySelectorAll('th').forEach(th => {
                th.addEventListener('click', () => {
                    const key = th.getAttribute('data-sort');
                    if (key) sortTable(key);
                });
            });

            window.addEventListener('scroll', handleScroll);
        });
    </script>
</body>

</html>
